# 进程

进程就是处于执行期的程序。

## 进程描述符及任务结构

### 进程描述符

内核通过一个唯一的进程标识值（PID，process identification）来标识每个进程。

### 进程状态

+ TASK_RUNNING（运行）
  
+ TASK_INTERRUPTIBLE（可中断）

+ TASK_UNINTERRUPTIBLE（不可中断）

+ __TASK_TRACED

  被其他进程跟踪的进程

+ __TASK_STOPPED（停止）

  进程停止执行。

### 进程上下文

### 进程家族数

## 进程创建

### fork

```fork()``` 通过拷贝当前进程创建一个子进程。

写时拷贝：父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制。

### exec

```exec()```负责读取可执行文件并将其载入地址空间开始运行。

## 进程终结

进程调用```exit()```系统调用时，既可能显示调用，也可能隐式调用（C语言编译器会在 ```main()```函数的返回点后面放置调用```exit()```的代码）。

当进程接受到它既不能处理也不能忽略的信号或异常时，它还可能被动地终结。

exit 实现：


### 删除进程描述符

进程调用```exit()```之后，进程已经僵尸不能再运行，但是系统还保留了它的进程描述符。这个可以让系统有办法在子进程终结后仍能获得它的信息。

wait：

挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的 PID。

### 孤儿进程

问题：父进程在子进程之前退出，如何保证子进程能找到一个新的父进程，否则这些孤儿的进程就会在退出时永远处理僵死状态，白白地耗费内存。

解决：给子进程在当前线程组内找一个线程作为父亲，如果不行，就让 init 做他们的父进程。

## 进程调度

多任务操作系统：能同时并发地执行多个进程的操作系统。

多任务系统分类：**非抢占式多任务**和抢占式多任务。

**抢占**：调度程序决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这个强制的动作就叫做**抢占**。

**进程的时间片**：分配给每个可运行进程的处理器时间段。

### 策略

I/O 消耗型进程：大部分时间用来提交 I/O 请求或是等待 I/O 请求。

处理器消耗型：时间大多用在执行代码上。除非被抢占，否则它们通常都一直不停地运行。

#### 进程优先级

优先级高的进程先运行，低的后运行，相同优先级的进程按轮训方式进行调度。

Linux 采用了两种不同的优先级范围：

+ nice 值

  范围 -20 ~ 19，默认值为 0，越大的 nice 值意味这个更低的优先级。低 nice 值（高优先级）的进程可以获得更多的处理器时间。

+ 实时优先级

  其值可配，默认 0 ~ 99，越高的实时优先级数值意味着进程优先级越高。任何实时进程的优先级都高于普通的进程。

#### 时间片

Linux  进程获得的处理器时间和系统负载密切相关。这个比例进一步还会受进程 nice 值的影响，nice 值作为权重将调整进程所使用的处理器时间使用比。

## 调度算法

### 公平调度

**理念**：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将能获得 1/n（可运行进程的数量） 的处理器时间。同时，我们

可以调度给它们无限小的时间周期，所以在任何可测量周期内，我们给予 n 个进程中每个进程同样多的运行时间。


为了确保系统性能不受损失：

  （1）CFS 的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了，
  CFS 在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠 nice 值来计算时间片。

  （2）nice 值在 CFS 中被作为进程获得的处理器运行比的权重：越高的 nice 值（越低的优先级）进程获得更低的处理器使用权重，这是相对默认 nice 值进程的进程而言的；
  相反，更低的 nice 值（越高的优先级）的进程获得更高的处理器使用权重。

每个进程都按其权重在全部可运行进程中所占比例的“时间片”来运行，为了计算准确的时间片，CFS 为完美多任务中的无限小调度周期的近似值设立了一个目标。而这个目标称作“目标延迟”，

越小的调度周期将带来越好的交互性，同时也更接近完美的多任务，

### 调度实现






